<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>å®¶åº­ç‡ƒæ°”ç›‘æ§ä¸­å¿ƒ</title>
    <script src="/static/chart.js"></script>
    <style>
      body {
        font-family: "Segoe UI", sans-serif;
        margin: 0;
        background: #f7f8fb;
        color: #333;
      }

      header {
        padding: 24px 32px;
        background: #111827;
        color: #fff;
      }

      header h1 {
        margin: 0 0 8px;
      }

      .status {
        display: flex;
        gap: 12px;
        align-items: center;
        padding: 16px 32px;
      }

      .badge {
        background: #fff;
        padding: 8px 12px;
        border-radius: 999px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
      }

      .metrics {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 16px;
        padding: 0 32px 24px;
      }

      .card {
        background: #fff;
        padding: 16px;
        border-radius: 12px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.06);
      }

      .card p {
        font-size: 20px;
        color: #ff5722;
      }

      .charts {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        gap: 16px;
        padding: 0 32px 24px;
      }

      .chart-card {
        background: #fff;
        padding: 16px;
        border-radius: 12px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.06);
      }

      /* Canvas å®¹å™¨ï¼Œé˜²æ­¢å›¾è¡¨æ— é™å¢é•¿ */
      .chart-container {
        position: relative;
        width: 100%;
        height: 300px;
        min-height: 300px;
        max-height: 300px;
      }

      button {
        padding: 8px 16px;
        border: none;
        border-radius: 8px;
        background: #2563eb;
        color: #fff;
        cursor: pointer;
      }

      button#refresh {
        background: #10b981;
      }

      .data {
        padding: 0 32px 24px;
      }

      .data table {
        width: 100%;
        background: #fff;
        border-radius: 12px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.06);
        border-collapse: collapse;
      }

      .data th,
      .data td {
        padding: 10px 12px;
        border-bottom: 1px solid #e5e7eb;
        text-align: left;
      }

      footer {
        padding: 16px 32px 32px;
        color: #6b7280;
      }

      /* åŠ è½½çŠ¶æ€æç¤º */
      .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.9);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 9999;
      }

      .loading-spinner {
        width: 50px;
        height: 50px;
        border: 4px solid #e5e7eb;
        border-top-color: #2563eb;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .loading-text {
        margin-top: 16px;
        font-size: 16px;
        color: #6b7280;
      }

      .error-message {
        background: #fee2e2;
        border: 1px solid #ef4444;
        border-radius: 8px;
        padding: 12px 16px;
        margin: 16px 32px;
        color: #991b1b;
        display: none;
      }

      .error-message.show {
        display: block;
      }

      /* ç§»åŠ¨ç«¯é€‚é… */
      @media (max-width: 640px) {
        header {
          padding: 16px;
        }

        .status {
          padding: 12px 16px;
          flex-wrap: wrap;
        }

        .metrics {
          padding: 0 16px 16px;
          grid-template-columns: repeat(2, 1fr);
        }

        .charts {
          padding: 0 16px 16px;
          grid-template-columns: 1fr;
        }

        .chart-container {
          height: 250px;
          min-height: 250px;
          max-height: 250px;
        }

        .data {
          padding: 0 16px 16px;
        }

        header h1 {
          font-size: 18px;
        }

        .card p {
          font-size: 16px;
        }

        .error-message {
          margin: 12px 16px;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <div
        style="
          display: flex;
          justify-content: space-between;
          align-items: center;
        "
      >
        <div>
          <h1>ğŸ”¥ å®¶åº­ç‡ƒæ°”ç›‘æ§ä¸­å¿ƒ</h1>
          <p>Go + MQTT + SQLite</p>
        </div>
        <div style="display: flex; gap: 12px">
          <a
            href="/"
            style="
              color: white;
              text-decoration: none;
              padding: 8px 16px;
              background: #374151;
              border-radius: 6px;
            "
            >ğŸ  é¦–é¡µ</a
          >
          <a
            href="/data-import"
            style="
              color: white;
              text-decoration: none;
              padding: 8px 16px;
              background: #374151;
              border-radius: 6px;
            "
            >âš™ï¸ å‚æ•°è®¾ç½®</a
          >
          <a
            href="/login"
            id="login-btn"
            style="
              color: white;
              text-decoration: none;
              padding: 8px 16px;
              background: #2563eb;
              border-radius: 6px;
              display: none;
            "
            >ğŸ” ç™»å½•</a
          >
          <button
            id="logout-btn"
            style="
              color: white;
              text-decoration: none;
              padding: 8px 16px;
              background: #dc2626;
              border: none;
              border-radius: 6px;
              cursor: pointer;
              display: none;
            "
          >
            é€€å‡º
          </button>
        </div>
      </div>
    </header>

    <!-- åŠ è½½çŠ¶æ€é®ç½© -->
    <div id="loading-overlay" class="loading-overlay">
      <div class="loading-spinner"></div>
      <p class="loading-text">æ­£åœ¨åŠ è½½æ•°æ®...</p>
    </div>

    <!-- é”™è¯¯æç¤º -->
    <div id="error-message" class="error-message"></div>

    <section class="status">
      <div id="mqtt-status" class="badge">MQTT: --</div>
      <div id="last-msg" class="badge">æœ€è¿‘æ¶ˆæ¯: --</div>
      <button id="refresh">åˆ·æ–°</button>
    </section>

    <section class="metrics">
      <div class="card">
        <h3>ğŸ“… ä»Šæ—¥ç”¨æ°”</h3>
        <p id="today-gas">--</p>
      </div>
      <div class="card">
        <h3>ğŸ—“ï¸ æœ¬å‘¨ç”¨æ°”</h3>
        <p id="week-gas">--</p>
      </div>
      <div class="card">
        <h3>ğŸˆ·ï¸ æœ¬æœˆç”¨æ°”</h3>
        <p id="month-gas">--</p>
      </div>
      <div class="card">
        <h3>ğŸ“Ÿ ç‡ƒæ°”è¡¨è¯»æ•°</h3>
        <p id="meter-reading">--</p>
      </div>
      <div class="card">
        <h3>ğŸ”‹ å‰©ä½™ç‡ƒæ°”</h3>
        <p id="remain-gas">--</p>
      </div>
    </section>

    <section class="charts">
      <div class="chart-card">
        <h3>ğŸ“ˆ ä»Šæ—¥æ¯å°æ—¶ç”¨é‡</h3>
        <div class="chart-container">
          <canvas id="hourly-chart"></canvas>
        </div>
      </div>
      <div class="chart-card">
        <h3>ğŸ“† å¹´åº¦ç”¨æ°”è¶‹åŠ¿</h3>
        <div class="chart-container">
          <canvas id="monthly-chart"></canvas>
        </div>
      </div>
    </section>

    <section class="data">
      <h2>ğŸ“ æœ€æ–°åŸå§‹æ•°æ®</h2>
      <table>
        <thead>
          <tr>
            <th>æ—¶é—´</th>
            <th>ç´¯è®¡è„‰å†²</th>
          </tr>
        </thead>
        <tbody id="recent-body"></tbody>
      </table>
    </section>

    <footer>
      <p>å®¶åº­ç‡ƒæ°”ç›‘æ§ç³»ç»Ÿ - æ•´åˆç‰ˆæœ¬</p>
    </footer>

    <script>
      const API_BASE = "/api";
      const REQUEST_TIMEOUT = 10000; // 10ç§’è¶…æ—¶

      // æ£€æŸ¥è®¤è¯çŠ¶æ€
      let isAuthEnabled = false;
      let isConfigured = false;

      async function checkAuthStatus() {
        try {
          const token = localStorage.getItem("gas_token");
          const res = await fetch(`${API_BASE}/auth/status`, {
            credentials: "include",
            headers: {
              ...(token ? { Authorization: `Bearer ${token}` } : {}),
            },
          });
          if (res.ok) {
            const data = await res.json();
            isAuthEnabled = data.enabled;
            isConfigured = data.configured;

            const loginBtn = document.getElementById("login-btn");
            const logoutBtn = document.getElementById("logout-btn");

            if (isAuthEnabled && isConfigured) {
              if (data.authenticated) {
                // å·²ç™»å½•
                loginBtn.style.display = "none";
                logoutBtn.style.display = "block";
              } else {
                // æœªç™»å½•
                loginBtn.style.display = "block";
                logoutBtn.style.display = "none";
              }
            } else {
              // è®¤è¯æœªå¯ç”¨
              loginBtn.style.display = "none";
              logoutBtn.style.display = "none";
            }
          }
        } catch (e) {
          console.error("æ£€æŸ¥è®¤è¯çŠ¶æ€å¤±è´¥:", e);
        }
      }

      // é€€å‡ºç™»å½•
      document.getElementById("logout-btn").addEventListener("click", () => {
        localStorage.removeItem("gas_token");
        fetch("/api/logout", { method: "POST", credentials: "include" }).finally(
          () => {
            window.location.href = "/login";
          }
        );
      });

      const metricsMap = {
        today_gas: "today-gas",
        week_gas: "week-gas",
        month_gas: "month-gas",
        meter_reading: "meter-reading",
        remain_gas: "remain-gas",
      };

      let hourlyChart;
      let monthlyChart;

      // éšè—åŠ è½½é®ç½©
      function hideLoading() {
        const overlay = document.getElementById("loading-overlay");
        if (overlay) {
          overlay.style.display = "none";
        }
      }

      // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
      function showError(message) {
        const errorDiv = document.getElementById("error-message");
        if (errorDiv) {
          errorDiv.textContent = "âš ï¸ " + message;
          errorDiv.classList.add("show");
        }
        hideLoading();
      }

      // æ¸…é™¤é”™è¯¯ä¿¡æ¯
      function clearError() {
        const errorDiv = document.getElementById("error-message");
        if (errorDiv) {
          errorDiv.classList.remove("show");
        }
      }

      // å¸¦è¶…æ—¶çš„ fetch è¯·æ±‚
      async function fetchJSON(path, options = {}) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), REQUEST_TIMEOUT);

        try {
          const res = await fetch(`${API_BASE}${path}`, {
            headers: { "Content-Type": "application/json" },
            signal: controller.signal,
            ...options,
          });
          clearTimeout(timeoutId);

          if (!res.ok) {
            const data = await res.json().catch(() => ({}));
            throw new Error(data.error || res.statusText);
          }
          return res.json();
        } catch (err) {
          clearTimeout(timeoutId);
          if (err.name === "AbortError") {
            throw new Error("è¯·æ±‚è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥");
          }
          throw err;
        }
      }

      async function loadMetrics() {
        try {
          const metrics = await fetchJSON("/metrics");
          if (!metrics) {
            console.error("Metrics data is null");
            return;
          }

          // è°ƒè¯•æ—¥å¿—
          console.log("è·å–åˆ°çš„ metrics æ•°æ®:", metrics);

          Object.entries(metricsMap).forEach(([key, id]) => {
            const el = document.getElementById(id);
            if (el) {
              if (metrics[key] !== undefined && metrics[key] !== null) {
                const newValue = `${metrics[key]} mÂ³`;
                console.log(
                  `æ›´æ–° DOM #${id} (${key}): "${el.textContent}" -> "${newValue}"`
                );
                el.textContent = newValue;
                // ç«‹å³éªŒè¯æ›´æ–°æ˜¯å¦æˆåŠŸ
                console.log(`éªŒè¯æ›´æ–°å #${id} å†…å®¹: "${el.textContent}"`);
              } else {
                console.warn(`æŒ‡æ ‡ ${key} ä¸å­˜åœ¨æˆ–ä¸º null`);
              }
            } else {
              console.error(`æ‰¾ä¸åˆ° DOM å…ƒç´  #${id}`);
            }
          });

          const status = document.getElementById("mqtt-status");
          if (status && metrics.mqtt_status !== undefined) {
            const oldStatus = status.textContent;
            status.textContent = `MQTT: ${metrics.mqtt_status}`;
            console.log(
              `MQTTçŠ¶æ€æ›´æ–°: "${oldStatus}" -> "${status.textContent}"`
            );
          }
          const lastMsg = document.getElementById("last-msg");
          if (lastMsg) {
            const oldMsg = lastMsg.textContent;
            lastMsg.textContent = `æœ€è¿‘æ¶ˆæ¯: ${metrics.last_msg_time || "--"}`;
            console.log(
              `æœ€è¿‘æ¶ˆæ¯æ›´æ–°: "${oldMsg}" -> "${lastMsg.textContent}"`
            );
          }

          // æ‰“å°æ‰€æœ‰å¡ç‰‡å…ƒç´ çš„å½“å‰å€¼
          console.log("=== DOMå…ƒç´ å½“å‰å€¼ ===");
          Object.values(metricsMap).forEach((id) => {
            const el = document.getElementById(id);
            if (el) {
              console.log(`#${id}: "${el.textContent}"`);
            }
          });
          console.log("=== DOMå…ƒç´ å½“å‰å€¼ç»“æŸ ===");
        } catch (err) {
          showError("åŠ è½½æŒ‡æ ‡æ•°æ®å¤±è´¥: " + err.message);
          console.error("åŠ è½½æŒ‡æ ‡å¤±è´¥:", err);
          throw err;
        }
      }

      async function loadHourlyChart() {
        try {
          const hourly = await fetchJSON("/hourly");
          if (!hourly || !Array.isArray(hourly)) {
            console.error("Hourly data is null or not an array");
            return;
          }

          const labels = Array.from(
            { length: 24 },
            (_, i) => `${String(i).padStart(2, "0")}:00`
          );

          const ctx = document.getElementById("hourly-chart");
          if (!ctx) {
            console.error("Hourly chart canvas not found");
            return;
          }

          // åªæ›´æ–°æ•°æ®ï¼Œé¿å…é—ªçƒ
          if (hourlyChart) {
            hourlyChart.data.datasets[0].data = hourly;
            hourlyChart.update("none"); // æ— åŠ¨ç”»æ›´æ–°
          } else {
            hourlyChart = new Chart(ctx, {
              type: "bar",
              data: {
                labels,
                datasets: [
                  {
                    label: "è„‰å†²æ•°",
                    data: hourly,
                    backgroundColor: "#00A3E0",
                  },
                ],
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: {
                  duration: 0, // é¦–æ¬¡åŠ è½½ä¹Ÿç¦ç”¨åŠ¨ç”»ï¼Œé¿å…é—ªçƒ
                },
                plugins: {
                  legend: {
                    display: false,
                  },
                },
                scales: {
                  y: {
                    beginAtZero: true,
                    ticks: {
                      maxTicksLimit: 6,
                    },
                  },
                  x: {
                    ticks: {
                      maxRotation: 45,
                      minRotation: 45,
                    },
                  },
                },
              },
            });
          }
        } catch (err) {
          showError("åŠ è½½æ¯å°æ—¶å›¾è¡¨å¤±è´¥: " + err.message);
          console.error("åŠ è½½æ¯å°æ—¶å›¾è¡¨å¤±è´¥:", err);
          throw err;
        }
      }

      async function loadMonthlyChart() {
        try {
          const monthly = await fetchJSON("/monthly");
          if (!monthly || !Array.isArray(monthly)) {
            console.error("Monthly data is null or not an array");
            return;
          }

          const labels = Array.from({ length: 12 }, (_, i) => `${i + 1}æœˆ`);

          const ctx = document.getElementById("monthly-chart");
          if (!ctx) {
            console.error("Monthly chart canvas not found");
            return;
          }

          // åªæ›´æ–°æ•°æ®ï¼Œé¿å…é—ªçƒ
          if (monthlyChart) {
            monthlyChart.data.datasets[0].data = monthly;
            monthlyChart.update("none"); // æ— åŠ¨ç”»æ›´æ–°
          } else {
            monthlyChart = new Chart(ctx, {
              type: "bar",
              data: {
                labels,
                datasets: [
                  {
                    label: "è„‰å†²æ•°",
                    data: monthly,
                    backgroundColor: "#FF6B6B",
                  },
                ],
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: {
                  duration: 0, // é¦–æ¬¡åŠ è½½ä¹Ÿç¦ç”¨åŠ¨ç”»ï¼Œé¿å…é—ªçƒ
                },
                plugins: {
                  legend: {
                    display: false,
                  },
                },
                scales: {
                  y: {
                    beginAtZero: true,
                    ticks: {
                      maxTicksLimit: 6,
                    },
                  },
                  x: {
                    ticks: {
                      maxRotation: 45,
                      minRotation: 45,
                    },
                  },
                },
              },
            });
          }
        } catch (err) {
          showError("åŠ è½½æœˆåº¦å›¾è¡¨å¤±è´¥: " + err.message);
          console.error("åŠ è½½æœˆåº¦å›¾è¡¨å¤±è´¥:", err);
          throw err;
        }
      }

      async function loadRecent() {
        try {
          const recent = await fetchJSON("/recent?limit=50");
          if (!recent || !Array.isArray(recent)) {
            console.error("Recent data is null or not an array");
            return;
          }

          const tbody = document.getElementById("recent-body");
          if (!tbody) {
            console.error("Recent data tbody not found");
            return;
          }

          tbody.innerHTML = "";
          recent.forEach((row) => {
            const tr = document.createElement("tr");
            const timeCell = document.createElement("td");
            const date = new Date(row.timestamp * 1000);
            timeCell.textContent = date.toLocaleString();
            const countCell = document.createElement("td");
            countCell.textContent = row.count;
            tr.appendChild(timeCell);
            tr.appendChild(countCell);
            tbody.appendChild(tr);
          });
        } catch (err) {
          showError("åŠ è½½æœ€è¿‘æ•°æ®å¤±è´¥: " + err.message);
          console.error("åŠ è½½æœ€è¿‘æ•°æ®å¤±è´¥:", err);
          throw err;
        }
      }

      let isFirstLoad = true;

      async function refreshAll() {
        if (isFirstLoad) {
          clearError();
        }
        try {
          await Promise.all([
            loadMetrics(),
            loadHourlyChart(),
            loadMonthlyChart(),
            loadRecent(),
          ]);
          hideLoading();
          isFirstLoad = false;
        } catch (err) {
          // åªåœ¨é¦–æ¬¡åŠ è½½æ—¶æ˜¾ç¤ºè¯¦ç»†é”™è¯¯ï¼Œè‡ªåŠ¨åˆ·æ–°æ—¶é™é»˜å¤±è´¥
          if (isFirstLoad) {
            console.error("æ•°æ®åŠ è½½å¤±è´¥:", err);
          }
          hideLoading();
        }
      }

      // è‡ªåŠ¨åˆ·æ–°å®šæ—¶å™¨
      let refreshTimer = null;

      function startAutoRefresh() {
        // æ¯ 5 ç§’è‡ªåŠ¨åˆ·æ–°ä¸€æ¬¡æ•°æ®ï¼Œæ›´å¿«åæ˜ æ•°æ®å˜åŒ–
        refreshTimer = setInterval(async () => {
          console.log("å¼€å§‹è‡ªåŠ¨åˆ·æ–°:", new Date().toLocaleTimeString());
          // é™é»˜åˆ·æ–°ï¼Œä¸æ˜¾ç¤ºé”™è¯¯æç¤ºï¼Œåªæ›´æ–°æ•°æ®
          // ä½¿ç”¨ Promise.allSettled ç¡®ä¿å³ä½¿æŸä¸ªè¯·æ±‚å¤±è´¥ï¼Œå…¶ä»–è¯·æ±‚ä»èƒ½å®Œæˆ
          const results = await Promise.allSettled([
            loadMetrics().catch((e) => {
              console.error("loadMetricså¤±è´¥:", e);
              return null;
            }),
            loadHourlyChart().catch((e) => {
              console.error("loadHourlyChartå¤±è´¥:", e);
              return null;
            }),
            loadMonthlyChart().catch((e) => {
              console.error("loadMonthlyChartå¤±è´¥:", e);
              return null;
            }),
            loadRecent().catch((e) => {
              console.error("loadRecentå¤±è´¥:", e);
              return null;
            }),
          ]);
          console.log(
            "è‡ªåŠ¨åˆ·æ–°å®Œæˆ:",
            new Date().toLocaleTimeString(),
            "ç»“æœ:",
            results.map((r) => r.status)
          );
        }, 5000); // 5ç§’åˆ·æ–°é—´éš”
      }

      function stopAutoRefresh() {
        if (refreshTimer) {
          clearInterval(refreshTimer);
          refreshTimer = null;
        }
      }

      async function init() {
        document
          .getElementById("refresh")
          .addEventListener("click", refreshAll);

        await checkAuthStatus();

        // ç­‰å¾…é¡µé¢å®Œå…¨åŠ è½½åå†åˆå§‹åŒ–æ•°æ®
        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", () => {
            refreshAll();
            startAutoRefresh(); // å¯åŠ¨è‡ªåŠ¨åˆ·æ–°
          });
        } else {
          refreshAll();
          startAutoRefresh(); // å¯åŠ¨è‡ªåŠ¨åˆ·æ–°
        }
      }

      // æ£€æŸ¥ Chart.js æ˜¯å¦åŠ è½½æˆåŠŸ
      if (typeof Chart === "undefined") {
        showError("Chart.js åº“åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•");
        hideLoading();
      } else {
        init();
      }
    </script>
  </body>
</html>
