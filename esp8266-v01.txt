#include <ESP8266WiFi.h>
#include <WiFiClientSecure.h> // 新增：TLS 支持
#include <PubSubClient.h>
#include <time.h>

// 传感器引脚配置
#define IR_PIN 5 // 红外传感器连接的 GPIO 引脚

// WiFi credentials
const char *ssid = "wifi";
const char *password = "passwd";

// MQTT Broker settings
const int mqtt_port = 8883;
const char *mqtt_broker = "hangzhou.emqxsl.cn";
const char *mqtt_topic = "gas/meter/pulses"; // 统一使用一个主题
const char *mqtt_username = "user";
const char *mqtt_password = "paswwd"; // 修复：移除错误的反斜杠

// NTP Server settings
const char *ntp_server = "cn.pool.ntp.org"; // 修复：正确的指针声明
const long gmt_offset_sec = 0;
const int daylight_offset_sec = 0;

// 全局变量
volatile int triggerCount = 0; // 红外触发计数器
volatile bool gasDetected = false; // 气体检测标志位
volatile bool shouldSend = false; // 新增：需要发送数据的标志位
volatile bool isProcessing = false; // 处理状态锁

volatile unsigned long lastTriggerTime = 0; // 记录最后一次有效触发时间
volatile unsigned long lastDebounceTime = 0; // 防抖时间记录

BearSSL::WiFiClientSecure espClient;
PubSubClient mqtt_client(espClient);

// 证书配置
static const char ca_cert[] PROGMEM = R"EOF(
-----BEGIN CERTIFICATE-----
证书内容
-----END CERTIFICATE-----
)EOF";

// Function declarations
void connectToWiFi();
void connectToMQTT();
void syncTime();
void mqttCallback(char *topic, byte *payload, unsigned int length);

// 中断服务函数（必须极简）
ICACHE_RAM_ATTR void sensorISR() {
unsigned long currentMillis = millis();

    // 200ms 防抖逻辑
    if (currentMillis - lastDebounceTime < 200) {
        return;
    }
    lastDebounceTime = currentMillis;

    // 5 秒间隔过滤 + 状态锁保护
    if (!isProcessing && (currentMillis - lastTriggerTime >= 5000)) {
        isProcessing = true;  // 锁定状态
        triggerCount++;       // 计数器递增
        lastTriggerTime = currentMillis;
        shouldSend = true;    // 标记需要发送
        gasDetected = true;
    }

}

void setup() {
Serial.begin(115200);
pinMode(IR_PIN, INPUT_PULLUP); // 启用内部上拉电阻
attachInterrupt(digitalPinToInterrupt(IR_PIN), sensorISR, FALLING); // 配置下降沿中断

    connectToWiFi();
    syncTime();
    mqtt_client.setServer(mqtt_broker, mqtt_port);
    mqtt_client.setCallback(mqttCallback);
    connectToMQTT();

}

void loop() {
// 保持 MQTT 连接
if (!mqtt_client.connected()) {
connectToMQTT();
}
mqtt_client.loop();

    // 发送数据（仅在 MQTT 连接成功时）
    if (gasDetected && shouldSend && mqtt_client.connected()) {
        String message = "{\"count\":" + String(triggerCount) +
                       ", \"timestamp\":" + String(time(nullptr)) + "}";

        if (mqtt_client.publish(mqtt_topic, message.c_str())) {
            Serial.printf("[MQTT] ✓ Sent count=%d at %lu\n", triggerCount, millis());
        } else {
            Serial.println("[MQTT] ✗ Publish failed");
        }

        gasDetected = false;
        shouldSend = false;
        isProcessing = false;  // 解锁，允许下一次中断
    }

}

void connectToWiFi() {
Serial.print("[WiFi] Connecting");
WiFi.begin(ssid, password);

    int retryCount = 0;
    while (WiFi.status() != WL_CONNECTED && retryCount < 30) {
        delay(500);
        Serial.print(".");
        retryCount++;
    }

    if (WiFi.status() == WL_CONNECTED) {
        Serial.println("\n[WiFi] ✓ Connected");
        Serial.print("[WiFi] IP address: ");
        Serial.println(WiFi.localIP());
    } else {
        Serial.println("\n[WiFi] ✗ Connection timeout, will retry...");
    }

}

void syncTime() {
configTime(gmt_offset_sec, daylight_offset_sec, ntp_server);
Serial.print("[NTP] Synchronizing time: ");

    // 等待时间同步完成（时间戳大于 2024-01-01）
    while (time(nullptr) < 1704067200) {
        delay(500);
        Serial.print(".");
    }
    Serial.println("\n[NTP] ✓ Time synchronized");

    struct tm timeinfo;
    if (getLocalTime(&timeinfo)) {
        Serial.print("[NTP] Current time: ");
        Serial.println(asctime(&timeinfo));
    } else {
        Serial.println("[NTP] ✗ Failed to obtain local time");
    }

}

void connectToMQTT() {
BearSSL::X509List serverTrustedCA(ca_cert);
espClient.setTrustAnchors(&serverTrustedCA);

    int retryCount = 0;
    while (!mqtt_client.connected() && retryCount < 10) {
        String client_id = "esp8266-client-" + String(WiFi.macAddress());
        Serial.printf("[MQTT] Attempt %d: Connecting as %s...\n", retryCount + 1, client_id.c_str());

        if (mqtt_client.connect(client_id.c_str(), mqtt_username, mqtt_password)) {
            Serial.println("[MQTT] ✓ Connected to broker");

            // 订阅命令主题，用于接收来自后端的控制命令
            mqtt_client.subscribe("gas/meter/commands");
            Serial.println("[MQTT] ✓ Subscribed to gas/meter/commands");

            // 发布连接成功消息
            mqtt_client.publish(mqtt_topic, "ESP8266 connected");
            break;
        } else {
            retryCount++;
            char err_buf[128];
            espClient.getLastSSLError(err_buf, sizeof(err_buf));
            Serial.print("[MQTT] ✗ Failed, rc=");
            Serial.print(mqtt_client.state());
            Serial.print(", SSL error: ");
            Serial.println(err_buf);
            delay(3000);
        }
    }

}

void mqttCallback(char *topic, byte *payload, unsigned int length) {
Serial.print("[MQTT] Message received on topic: ");
Serial.print(topic);
Serial.print("]: ");
for (int i = 0; i < length; i++) {
Serial.print((char) payload[i]);
}
Serial.println();

    // 处理接收到的命令
    // 示例：如果收到 "reset" 命令，重置计数器
    // String message = "";
    // for (int i = 0; i < length; i++) {
    //     message += (char)payload[i];
    // }
    // if (message == "reset") {
    //     triggerCount = 0;
    //     Serial.println("[CMD] Counter reset");
    // }

}
