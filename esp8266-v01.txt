#include <ESP8266WiFi.h>
#include <WiFiClientSecure.h> // 新增：TLS 支持
#include <ESP8266httpUpdate.h> // 新增：HTTP OTA 支持
#include <PubSubClient.h>
#include <time.h>
#include <ArduinoOTA.h> // 新增：本地 OTA 支持

// 传感器引脚配置
#define IR_PIN 5 // 红外传感器连接的 GPIO 引脚

// WiFi credentials
const char *ssid = "wifi";
const char *password = "passwd";

// MQTT Broker settings
const int mqtt_port = 8883;
const char *mqtt_broker = "hangzhou.emqxsl.cn";
const char *mqtt_topic = "gas/meter/pulses"; // 统一使用一个主题
const char *mqtt_username = "user";
const char *mqtt_password = "paswwd"; // 修复：移除错误的反斜杠

// NTP Server settings
const char *ntp_server = "cn.pool.ntp.org"; // 修复：正确的指针声明
const long gmt_offset_sec = 0;
const int daylight_offset_sec = 0;

// 全局变量
volatile int triggerCount = 0; // 红外触发计数器
volatile bool gasDetected = false; // 气体检测标志位
volatile bool shouldSend = false; // 新增：需要发送数据的标志位
volatile bool isProcessing = false; // 处理状态锁

volatile unsigned long lastTriggerTime = 0; // 记录最后一次有效触发时间
volatile unsigned long lastDebounceTime = 0; // 防抖时间记录

BearSSL::WiFiClientSecure espClient;
PubSubClient mqtt_client(espClient);

// 证书配置
static const char ca_cert[] PROGMEM = R"EOF(
-----BEGIN CERTIFICATE-----
证书内容
-----END CERTIFICATE-----
)EOF";

// Function declarations
void connectToWiFi();
void connectToMQTT();
void syncTime();
void mqttCallback(char *topic, byte *payload, unsigned int length);
void setupOTA(); // 新增：OTA 初始化函数
void performOTAUpdate(const char* updateUrl); // 新增：执行 OTA 升级

// 中断服务函数（必须极简）
ICACHE_RAM_ATTR void sensorISR() {
unsigned long currentMillis = millis();

    // 200ms 防抖逻辑
    if (currentMillis - lastDebounceTime < 200) {
        return;
    }
    lastDebounceTime = currentMillis;

    // 5 秒间隔过滤 + 状态锁保护
    if (!isProcessing && (currentMillis - lastTriggerTime >= 5000)) {
        isProcessing = true;  // 锁定状态
        triggerCount++;       // 计数器递增
        lastTriggerTime = currentMillis;
        shouldSend = true;    // 标记需要发送
        gasDetected = true;
    }

}

void setup() {
Serial.begin(115200);
pinMode(IR_PIN, INPUT_PULLUP); // 启用内部上拉电阻
attachInterrupt(digitalPinToInterrupt(IR_PIN), sensorISR, FALLING); // 配置下降沿中断

    connectToWiFi();
    syncTime();
    setupOTA(); // 新增：初始化 OTA 服务
    mqtt_client.setServer(mqtt_broker, mqtt_port);
    mqtt_client.setCallback(mqttCallback);
    connectToMQTT();

}

void loop() {
// 保持 MQTT 连接
if (!mqtt_client.connected()) {
connectToMQTT();
}
mqtt_client.loop();
ArduinoOTA.handle(); // 新增：处理 OTA 请求

    // 发送数据（仅在 MQTT 连接成功时）
    if (gasDetected && shouldSend && mqtt_client.connected()) {
        String message = "{\"count\":" + String(triggerCount) +
                       ", \"timestamp\":" + String(time(nullptr)) + "}";

        if (mqtt_client.publish(mqtt_topic, message.c_str())) {
            Serial.printf("[MQTT] ✓ Sent count=%d at %lu\n", triggerCount, millis());
        } else {
            Serial.println("[MQTT] ✗ Publish failed");
        }

        gasDetected = false;
        shouldSend = false;
        isProcessing = false;  // 解锁，允许下一次中断
    }

}

void connectToWiFi() {
Serial.print("[WiFi] Connecting");
WiFi.begin(ssid, password);

    int retryCount = 0;
    while (WiFi.status() != WL_CONNECTED && retryCount < 30) {
        delay(500);
        Serial.print(".");
        retryCount++;
    }

    if (WiFi.status() == WL_CONNECTED) {
        Serial.println("\n[WiFi] ✓ Connected");
        Serial.print("[WiFi] IP address: ");
        Serial.println(WiFi.localIP());
    } else {
        Serial.println("\n[WiFi] ✗ Connection timeout, will retry...");
    }

}

void syncTime() {
configTime(gmt_offset_sec, daylight_offset_sec, ntp_server);
Serial.print("[NTP] Synchronizing time: ");

    // 等待时间同步完成（时间戳大于 2024-01-01）
    while (time(nullptr) < 1704067200) {
        delay(500);
        Serial.print(".");
    }
    Serial.println("\n[NTP] ✓ Time synchronized");

    struct tm timeinfo;
    if (getLocalTime(&timeinfo)) {
        Serial.print("[NTP] Current time: ");
        Serial.println(asctime(&timeinfo));
    } else {
        Serial.println("[NTP] ✗ Failed to obtain local time");
    }

}

void connectToMQTT() {
BearSSL::X509List serverTrustedCA(ca_cert);
espClient.setTrustAnchors(&serverTrustedCA);

    int retryCount = 0;
    while (!mqtt_client.connected() && retryCount < 10) {
        String client_id = "esp8266-client-" + String(WiFi.macAddress());
        Serial.printf("[MQTT] Attempt %d: Connecting as %s...\n", retryCount + 1, client_id.c_str());

        if (mqtt_client.connect(client_id.c_str(), mqtt_username, mqtt_password)) {
            Serial.println("[MQTT] ✓ Connected to broker");

            // 订阅命令主题，用于接收来自后端的控制命令
            mqtt_client.subscribe("gas/meter/commands");
            Serial.println("[MQTT] ✓ Subscribed to gas/meter/commands");

            // 发布连接成功消息
            mqtt_client.publish(mqtt_topic, "ESP8266 connected");
            break;
        } else {
            retryCount++;
            char err_buf[128];
            espClient.getLastSSLError(err_buf, sizeof(err_buf));
            Serial.print("[MQTT] ✗ Failed, rc=");
            Serial.print(mqtt_client.state());
            Serial.print(", SSL error: ");
            Serial.println(err_buf);
            delay(3000);
        }
    }

}

void mqttCallback(char *topic, byte *payload, unsigned int length) {
Serial.print("[MQTT] Message received on topic: ");
Serial.print(topic);
Serial.print("]: ");
for (int i = 0; i < length; i++) {
Serial.print((char) payload[i]);
}
Serial.println();

    // 处理接收到的命令
    String message = "";
    for (int i = 0; i < length; i++) {
        message += (char)payload[i];
    }
    
    // 重置计数器命令
    if (message == "reset") {
        triggerCount = 0;
        Serial.println("[CMD] Counter reset");
        mqtt_client.publish(mqtt_topic, "{\"status\":\"reset_ok\"}");
    }
    // OTA 升级命令：格式 {"ota":"http://server/firmware.bin"}
    else if (message.startsWith("{\"ota\":")) {
        // 解析 JSON 获取升级 URL
        int urlStart = message.indexOf("\"ota\":\"") + 7;
        int urlEnd = message.indexOf("\"", urlStart);
        if (urlStart > 6 && urlEnd > urlStart) {
            String updateUrl = message.substring(urlStart, urlEnd);
            Serial.printf("[OTA] Update requested: %s\n", updateUrl.c_str());
            mqtt_client.publish(mqtt_topic, "{\"status\":\"ota_started\"}");
            performOTAUpdate(updateUrl.c_str());
        } else {
            Serial.println("[OTA] Invalid OTA command format");
            mqtt_client.publish(mqtt_topic, "{\"status\":\"ota_error\",\"error\":\"invalid_format\"}");
        }
        
        // 新增：初始化本地 OTA 服务（通过 Arduino IDE 等工具）
        void setupOTA() {
            Serial.println("[OTA] Initializing ArduinoOTA...");
            
            // 设置 OTA 主机名
            ArduinoOTA.setHostname("gas-meter-esp8266");
            
            // 设置 OTA 密码（可选，建议设置）
            // ArduinoOTA.setPassword("admin123");
            
            // 开始事件 - 设备开始接收 OTA 升级
            ArduinoOTA.onStart([]() {
                Serial.println("[OTA] Start updating...");
                // 停止中断，避免升级过程中传感器干扰
                detachInterrupt(digitalPinToInterrupt(IR_PIN));
            });
            
            // 结束事件 - 升级完成
            ArduinoOTA.onEnd([]() {
                Serial.println("\n[OTA] Update successful!");
            });
            
            // 进度事件 - 显示升级进度
            ArduinoOTA.onProgress([](unsigned int progress, unsigned int total) {
                Serial.printf("[OTA] Progress: %u%%\r", (progress / (total / 100)));
            });
            
            // 错误事件 - 升级失败
            ArduinoOTA.onError([](ota_error_t error) {
                Serial.printf("[OTA] Error[%u]: ", error);
                if (error == OTA_AUTH_ERROR) Serial.println("Auth Failed");
                else if (error == OTA_BEGIN_ERROR) Serial.println("Begin Failed");
                else if (error == OTA_CONNECT_ERROR) Serial.println("Connect Failed");
                else if (error == OTA_RECEIVE_ERROR) Serial.println("Receive Failed");
                else if (error == OTA_END_ERROR) Serial.println("End Failed");
            });
            
            ArduinoOTA.begin();
            Serial.printf("[OTA] Ready on IP %s, port %d\n", WiFi.localIP().toString().c_str(), 8266);
        }
        
        // 新增：执行 HTTP OTA 升级（通过远程 URL）
        void performOTAUpdate(const char* updateUrl) {
            Serial.println("[OTA] Starting HTTP OTA update...");
            Serial.printf("[OTA] URL: %s\n", updateUrl);
            
            // 停止中断，避免升级过程中传感器干扰
            detachInterrupt(digitalPinToInterrupt(IR_PIN));
            
            // 断开 MQTT 连接，释放网络资源
            mqtt_client.disconnect();
            
            // 开始 HTTP OTA 升级
            HTTPUpdate.onStart([]() {
                Serial.println("[OTA] HTTP update started...");
                String msg = "{\"status\":\"ota_downloading\"}";
                // 注意：此时 MQTT 已断开，无法发送
            });
            
            HTTPUpdate.onEnd([]() {
                Serial.println("[OTA] HTTP update finished!");
                Serial.println("[OTA] Rebooting...");
            });
            
            HTTPUpdate.onProgress([](int progress, int total) {
                Serial.printf("[OTA] HTTP Progress: %d%%\r", (progress / (total / 100)));
            });
            
            HTTPUpdate.onError([](int error) {
                Serial.printf("[OTA] HTTP Error[%d]: ", error);
                if (error == HTTP_UPDATE_NO_UPDATES) Serial.println("No updates available");
                else if (error == HTTP_UPDATE_FAILED) Serial.println("Update failed");
                else Serial.println("Unknown error");
            });
            
            // 获取当前时间戳用于版本标识
            unsigned long startTime = millis();
            
            // 执行升级
            WiFiClient client;
            t_httpUpdate_return ret = ESPhttpUpdate.update(client, updateUrl);
            
            // 升级后的处理（如果没有重启）
            switch (ret) {
                case HTTP_UPDATE_FAILED:
                    Serial.printf("[OTA] HTTP update failed (error %d): %s\n",
                                 ESPhttpUpdate.getLastError(),
                                 ESPhttpUpdate.getLastErrorString().c_str());
                    // 升级失败后重新启用中断和 MQTT
                    attachInterrupt(digitalPinToInterrupt(IR_PIN), sensorISR, FALLING);
                    connectToMQTT();
                    break;
                    
                case HTTP_UPDATE_NO_UPDATES:
                    Serial.println("[OTA] No updates available");
                    attachInterrupt(digitalPinToInterrupt(IR_PIN), sensorISR, FALLING);
                    connectToMQTT();
                    break;
                    
                case HTTP_UPDATE_OK:
                    Serial.println("[OTA] HTTP update successful!");
                    // 升级成功后 ESP8266 会自动重启
                    break;
            }
        }
    }
    // 查询固件版本
    else if (message == "version") {
        String versionMsg = "{\"version\":\"v0.0.2\",\"status\":\"ok\"}";
        mqtt_client.publish(mqtt_topic, versionMsg.c_str());
        Serial.println("[CMD] Version query responded");
    }

}
